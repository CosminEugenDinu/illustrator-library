
/**
* @@@BUILDINFO@@@ Img_constructor.jsx !Version! Tue Feb 05 2019 11:18:06 GMT+0200
*/
/*============================ MatrixJS method =======================*/
/* MatrixJS properties:
    // parameters: 
// matrixPosition = [x, y]; default = origin = [0, 0];
// matrixDimensions = [xMatrixDimension, yMatrixDimension]; default = [100, 100]; xMatrixDimension = matrixWidth (horizontal); yMatrixDimension = matrixHeight (vertical);
// cells = [xCells, yCells]; default = [2, 2]; xCells = number of columns; yCells = number of rows; 
// cellScaleFactors = [x%, y%]; default = [50, 50]; alignament within the virtul cell in the matrix; center_Alignment = [50, 50]; left_bottom_Alignment = [0, 0]; right_top_Alignment = [100, 100]; etc.;
   MatrixJS.matrixPosition = [x, y]; (r | w);
   MatrixJS.matrixDimensions = [xMatrixDimension, yMatrixDimension]; (r | w);
   MatrixJS.cells= [xCells, yCells]; (r | w); 
   MatrixJS.cellScaleFactors = [x%, y%]; (r | w);
    // autogenerated //
   MatrixJS._mPositions = this.generate_mPositions();  => [ [array of x arrays], [array of y arrays] ];)();
                                        returns [ 
                                                        [ [x1, y1], [x2, y1] ],
                                                        [ [x1, y1], [x1, y2] ]
                                                    ]; (r only); and assigns to MatrixJS._mPositions;                                             
   MatrixJS.get_mPositions(); // gets all positios // example: var myPos = myMatrix.get_mPositions()[4][5]; // returns [x,y]; or myMatrix.get_mPositions(); // returns all positions;  
   MatrixJS.getCellDimensions() => [xCellDimension, yCellDimension]; (r only);
   MatrixJS.getCellPosition(x, y) => [x, y]; (r only); // the origin position of specific cell inside the matrix;  
*/
var pt = 2.83464567 ;

function MatrixJS (matrixPosition, matrixDimensions, cells, cellScaleFactors) {
                            var defaults = [[0, 0], [100, 100], [2, 2], [50, 50]];
    
    this.matrixPosition= defaults[0];
    this.matrixDimensions = defaults[1];
    this.cells = defaults[2];
    this.cellScaleFactors = defaults[3];
    
    if (arguments[0]) this.matrixPosition = arguments[0];
    if (arguments[1]) this.matrixDimensions =arguments[1];
    if (arguments[2]) this.cells = arguments[2];
    if (arguments[3]) this.cellScaleFactors = arguments[3];
   
    this._mPositions = [];
    this.generate_mPositions();
    }
MatrixJS.prototype.generate_mPositions = function () {
                        var xCells = this.cells[0]; // columns
                        var yCells = this.cells[1]; // rows
                        var numOfCells = xCells*yCells;
                        var xMatrixDimension = this.matrixDimensions[0];
                        var yMatrixDimension = this.matrixDimensions[1];
                        var xCellDimension = xMatrixDimension/xCells;
                        var yCellDimension = yMatrixDimension/yCells;
                        var matrix = [];
                       for (var i=0; i<xCells; i++) {
                           var row = [];
                            var xPos = this.matrixPosition[0] + (xCellDimension*i)+(xCellDimension*(this.cellScaleFactors[0]/100));
                                for (var j=0; j<yCells; j++) {
                                    var yPos =  this.matrixPosition[1] + (yCellDimension*j)+(yCellDimension*(this.cellScaleFactors[1]/100));
                                    row.push([xPos, yPos]);
                                    }    
                           matrix.push(row);
                           }
                        this._mPositions = matrix;
                        return this._mPositions;
    };
MatrixJS.prototype.get_mPositions = function (x, y) {
    if (arguments.length === 0) return this._mPositions; 
    else return this._mPositions[x][y];
    };
MatrixJS.prototype.get_mPositions_lrtb = function () {
    var allPos_lrtb = [];
    var yCells = this.cells[1];
    var xCells = this.cells[0];
         for (var y=yCells-1; y >=0; y--) {
             for (var x=0; x<xCells; x++) {
                       allPos_lrtb.push(this._mPositions[x][y]);
                 }
             }
         return allPos_lrtb;
    };

MatrixJS.prototype.getCellDimensions= function () {
    var xCellDimension = this.matrixDimensions[0]/this.cells[0];
    var yCellDimension = this.matrixDimensions[1]/this.cells[1];
    return [xCellDimension, yCellDimension];
    };

MatrixJS.prototype.getCellPosition = function (x, y) {
    var pos = this.get_mPositions(x, y);
    var d = this.getCellDimensions();
    var a = pos[0]-((this.cellScaleFactors[0]/100)*d[0]);
    var b = pos[1]-((this.cellScaleFactors[1]/100)*d[0]);
    return [a, b];
    };
/* // TEST
// function MatrixJS (matrixPosition, matrixDimensions, cells, cellScaleFactors)

var myMatrix = new MatrixJS([0,0], [10, 10], [10, 10], [0, 0]);
var myPos = myMatrix.get_mPositions()[4][3];
var myPos2 = myMatrix.get_mPositions(0, 0);
var celPos =  myMatrix.getCellPosition(1, 1);
var celD = myMatrix.getCellDimensions();
*/

/*============================ MatrixJS method END =======================*/


function Img (width, height) {
    this.src = ''; // relative path // relativeURI in file obj
    this.file = ''; // file object
    this.width= width;
    this.height = height;
    this.naturalWidth = ''; // initial size of original image
    this.naturalHeight = ''; // initial size of original image
    this.embed = false; // if set to false, image file will be placed as link
    this.autorotate = true;
    this.style = {
        top: 600,
        left: 100,
        borderStyle: 'solid', // none | dotted | dashed | solid ;
        borderWidth: 2,
        borderColor: [10,10,10,10], 
        borderRadius: 0,
        backgroundColor: 'transparent', // [c, m, y, k] | 'transparent'
        paddingLeft: 1,
        paddingTop: 1,
        paddingRight: 1,
        paddingBottom: 1,
        objectPosition: ['center', 'center'], // [ 'left' | 'center' | 'right' ,  'top' | 'center' | 'bottom' ]
        objectFit: 'cover', // fill | contain | cover | none | scale-down // scale-down means that if the image is smaller than the width/height will remain the same size (as if 'none') and if the image is bigger will be resized to fit (as if 'contain')...............
        };
    }

Img.prototype.selectImgFile = function () {
    var currentPath = new File($.fileName).path;
    this.file = new File(currentPath).openDlg('Select file...  any File containing an image...', "*.*", false); // false is for multiselect
    // if user cancel file selection
    if (!this.file) return; else if (typeof this.file == 'object') this.src = this.file.relativeURI;
    };
Img.prototype.render = function (position) {   
    if (app.documents.length == 0) {
        $.writeln('-->Img.prototype.render: No Document!');
        return;
        }
    if (!this.file&&!this.src) {
        $.writeln('-->Img.render: "no file!"');
        return;
        };
    var imgGroup = app.activeDocument.groupItems.add();
    imgGroup.name = 'imgGroup';
    var style = this.style;
    var paddingW = this.style.paddingLeft  +this.style.paddingRight;
    var paddingH = this.style.paddingTop + this.style.paddingBottom;
    var imgRect = imgGroup.pathItems.roundedRectangle(style.top+style.paddingTop, style.left-style.paddingLeft, this.width+paddingW, this.height+paddingH, style.borderRadius, style.borderRadius);
    // border
      switch (style.borderStyle) {
          case 'none' : imgRect.stroked = false; break;// false for borderStyle : 'none'; 
          case 'solid' : {      
                imgRect.stroked = true;       
                imgRect.strokeDashes = []; // Array of numbers // Dash lengths (set to [ ] for a solid line); // solid line <= borderStyle = 'solid';
                imgRect.strokeWidth = style.borderWidth; // if  borderStyle : dotted | dashed | solid ;
                imgRect.strokeColor = CMYK(style.borderColor) ; // if  borderStyle : dotted | dashed | solid ;
              }; break;
          case 'dotted' : {
                imgRect.stroked = true;                          
                imgRect.strokeDashes = [style.borderWidth, style.borderWidth]; // if borderStyle = dotted;
                imgRect.strokeDashOffset = style.borderWidth/2; // The default distance into the dash pattern at which the pattern should be started.
                imgRect.strokeWidth = style.borderWidth; // if  borderStyle : dotted | dashed | solid ;
                imgRect.strokeColor = CMYK(style.borderColor) ; // if  borderStyle : dotted | dashed | solid ;
              }; break;
          case 'dashed' : {
                imgRect.stroked = true;
                if (! style.dashPattern)
                imgRect.strokeDashes = [style.borderWidth*2, style.borderWidth]; // if borderStyle = dashed;
                else
                imgRect.strokeDashes = style.dashPattern; // if borderStyle = dashed; and dashPattern
                imgRect.strokeDashOffset = style.borderWidth/2 ; // The default distance into the dash pattern at which the pattern should be started.
                imgRect.strokeWidth = style.borderWidth; // if  borderStyle : dotted | dashed | solid ;
                imgRect.strokeColor = CMYK(style.borderColor) ; // if  borderStyle : dotted | dashed | solid ;               
              }; break;
          default : {
                imgRect.stroked = true;       
                imgRect.strokeDashes = []; // Array of numbers // Dash lengths (set to [ ] for a solid line); // solid line <= borderStyle = 'solid';
                imgRect.strokeWidth = style.borderWidth; // if  borderStyle : dotted | dashed | solid ;
                imgRect.strokeColor = CMYK(style.borderColor); // if  borderStyle : dotted | dashed | solid ;
              };
          }
    // backgroundColor
    var bc = style.backgroundColor;
    imgRect.filled = (! bc || bc == 'transparent') ? false : true;
    if (imgRect.filled) imgRect.fillColor = CMYK(bc);   
    // clipping Group
    var clippG = imgGroup.groupItems.add();
    // add img file
    var img = clippG.placedItems.add();
    var f = !this.file ? new File(this.src) : this.file;
    if (f.name.match(/\.pdf$/i)) { // checks if the selected document (f) is a PDF file
    app.preferences.PDFFileOptions.pageToOpen = prompt ('Select a page for image file!', 1, 'Your answer here...'); // app.preferences.PDFFileOptions.pageToOpen = {{which page to open}}
    }
    try {
        img.file = f;
        } catch (e) {
            $.writeln(e);
            return;
            }
    
 
    img.name = img.file.name;

    this.naturalWidth = img.width;
    this.naturalHeight = img.height;
    // autorotate
    var ir = img.width/img.height; // image aspect ratio
    var cr = this.width/this.height; // container aspect ratio
    if (this.autorotate && ((ir<1&&cr>1)||(ir>1&&cr<1))) img.rotate(90);
//~     if (this.autorotate && (ir<1&&cr>1)) img.rotate(90);
    // objectFit
    switch (style.objectFit) {
        case 'fill' : {
            img.width = this.width;
            img.height = this.height;
            }; break;
        case 'contain': {
            ir = img.width/img.height; // reasigned if autorotate
            cr = this.width/this.height; // reasigned if autorotate
            if (cr/ir>=1) {
                img.height = this.height;
                img.width = img.height*ir;
                } else if (cr/ir<1) {
                    img.width = this.width;
                    img.height = img.width/ir;
                    }
            }; break;
        case 'cover': {
            ir = img.width/img.height; // reasigned if autorotate
            cr = this.width/this.height; // reasigned if autorotate
            if (cr/ir<1) {
                img.height = this.height;
                img.width = img.height*ir;
                } else if (cr/ir>=1) {
                    img.width = this.width;
                    img.height = img.width/ir;
                    }
            }; break;
        case 'none': {
            var doNothing = 'nothing';
            }; break;
        case 'scale-down': {
            if (img.width>this.width&&img.height>this.height) {
                // code from 'contain'
                ir = img.width/img.height; // reasigned if autorotate
                cr = this.width/this.height; // reasigned if autorotate
                if (cr/ir>=1) {
                    img.height = this.height;
                    img.width = img.height*ir;
                    } else if (cr/ir<1) {
                        img.width = this.width;
                        img.height = img.width/ir;
                        }
                }       
            }; break;
        default : ;
        }
    // objectPosition (for image)
    var pip = [0,0];  // placedItem.position // image position
    var op = style.objectPosition;
    switch (op[0]) {  // setting X position (horrizonlal / left);
        case 'left' : pip[0] = style.left; break;
        case 'center' : pip[0] = style.left+(this.width/2)-(img.width/2); break;
        case 'right' : pip[0] = style.left+this.width-img.width; break;
        default : pip[0] = style.left;
        }
    switch (op[1]) { // setting Y position (vertical / top)
        case 'top' : pip[1] = style.top; break;
        case 'center' : pip[1] = style.top - (this.height/2)+(img.height/2); break;
        case 'bottom' : pip[1] = style.top-this.height+img.height; break;
        default : pip[1] = style.top;
        }
    img.position = pip;
 
    if (this.embed) img.embed();
    // add clipping path
    var clipp = clippG.pathItems.roundedRectangle(style.top, style.left, this.width, this.height, style.borderRadius, style.borderRadius);
    clipp.clipping = true;
    clippG.clipped = true;

    function CMYK (col) {
        var c = new CMYKColor();
        c.cyan = col[0];
        c.magenta = col[1];
        c.yellow = col[2];
        c.black = col[3] 
        return c;
            }
return {
    img: img,
    imgClipping: '',
    imgRect: imgRect,
    another: 'ano',
    };
};

// TEST

// makeDoc ('poze', 330, 487, 1)
// var aImg = new Img(200, 400);
// aImg.src = '../../../../../../Users/Cut/Google%20Drive/gradinita/JETOANE%20MATE/4iw8z5071wzp.png'; // relative path // relativeURI in file obj
// aImg.selectImgFile ();
// var are = aImg.render();

function makeDoc (docName, artWidth, artHeight, artNr, units) {
    var mm = (arguments[4]&&arguments[4] === 'mm') ? true : false;
    var pt = 2.83464567; // // 1 millimeter = 2.83464567 PostScript points
    var myPreset = new DocumentPreset();
    myPreset.title = docName;
    myPreset.width = (mm) ? artWidth*pt : artWidth;
    myPreset.height = (mm) ? artHeight*pt : artHeight;
    myPreset.numArtboards = artNr;
    myPreset.artboardLayout = DocumentArtboardLayout.Column;
    myPreset.units = (mm) ? RulerUnits.Millimeters : RulerUnits.Points;
    myPreset.colorMode = DocumentColorSpace.CMYK;
    var myDoc =app.documents.addDocument("Print", myPreset, false);
    return myDoc; // myDoc is a reference to newly created Document;
    };


var currentPath = new File($.fileName).path;

// var folder = Folder(currentPath).selectDlg();
// var files = folder.getFiles()
// var paths = []
// for (var i = 0; i < files.length; i++) {
//     // alert(files[i].fullName)
//     var spl = files[i].fullName.split('.')
//     var fileExtension = spl[spl.length-1]

//     if (fileExtension === 'jpg') {
//         paths.push(files[i].fullName)
//     } 
// }
// // alert(paths[0])

// makeDoc ('poze', 487, 330, 1)
// var aImg = new Img(110, 160);
// // aImg.src = '../../../../../../Users/Cut/Google%20Drive/gradinita/JETOANE%20MATE/4iw8z5071wzp.png'; // relative path // relativeURI in file obj
// // aImg.selectImgFile ();
// // var are = aImg.render();


// var myMatrix = new MatrixJS([165,10], [320, 480], [2, 4], [0, 0]);

// var positions = myMatrix.get_mPositions_lrtb ();
// // alert (positions[0])

// for (var j = 0; j < paths.length; j++) {
//     aImg.src = paths[j];

//     aImg.style.left = positions[j][1];
//     aImg.style.top = positions[j][0];
//     aImg.render()
// }

function ImgDocumentCreator(artboard_width, artboard_height, img_width, img_height, img_style, print_margins) {
    this.artboard_width = artboard_width;
    this.artboard_height = artboard_height;
    this.img_width = img_width;
    this.img_height = img_height;
    this.img_stype = null;
    this.print_margins = print_margins; // { left: 5, right: 5, top: 7, bottom:7 } (mm)
    
    this.img_folder;
}

ImgDocumentCreator.prototype._get_nums_input = function (prompt_title, prompt_message, default_value) {
    var input_str = prompt(prompt_message, default_value, prompt_title);
    var input_str_list = input_str.split(' ');
    var nums = Array( Number(input_str_list[0]), Number(input_str_list[1]))
    return nums
    }

ImgDocumentCreator.prototype.set_artboard_dimensions = function() {
    var prompt_title = 'ARTBOARD Dimensions Width Height';
    var prompt_message = 'ARTBOARD dimensions (mm) like "xx yy" ';
    var default_value = '330 487';
    var inserted_values = this._get_nums_input (prompt_title, prompt_message, default_value);
    var pt = 2.83464567 ;
    this.artboard_width = inserted_values[0]*pt;
    this.artboard_height = inserted_values[1]*pt;
//~     alert(typeof this.artboard_width);
//~     alert(typeof this.artboard_height);
    };
ImgDocumentCreator.prototype.set_img_dimensions = function(){
    var prompt_title = 'IMAGE Object Dimensions Width Height';
    var prompt_message = 'IMAGE dimensions (mm) like "xx yy" ';
    var default_value = '147 210';
    var inserted_values = this._get_nums_input(prompt_title, prompt_message, default_value);
    var pt = 2.83464567 ;
    this.img_width = inserted_values[0] * pt;
    this.img_height = inserted_values[1] *pt;
//~     alert(this.img_width)
//~     alert(typeof this.img_width)
//~     alert(this.img_height)
//~     alert(typeof this.img_width)
    
    };
ImgDocumentCreator.prototype.select_img_folder = function(){
    var currentPath = new File($.fileName).path;
    var folder = Folder(currentPath).selectDlg('SELECT Images Folder');
    this.img_folder = folder;
//~     alert(this.img_folder);
    };
ImgDocumentCreator.prototype.render = function() {
    var img_paths = [];
    var files = this.img_folder.getFiles();
    
    for (var i = 0; i < files.length; i++) {
      // alert(files[i].fullName)
    var spl = files[i].fullName.split('.');
    var fileExtension = spl[spl.length-1]

        if (fileExtension === 'jpg' || fileExtension === 'png') {
        img_paths.push(files[i].fullName)
        } 
        
        }
//~     alert(img_paths)
    var num_of_img = img_paths.length;
    
    // arrangement of img objects on artboard
    
    // max num of placeholders on artboard
    var img_placeholder = [this.img_width, this.img_height];
    var rotate_img_dimensions = false;
    var max_num_of_placeholders = 0;
    var artboard_ratio = this.artboard_width / this.artboard_height;
    var max_img_widths_on_artboard_width = Math.floor( (this.artboard_width - (this.print_margins.left + this.print_margins.right)) / 
        this.img_width);    
//~     alert(max_img_widths_on_artboard_width);
    var max_img_widths_on_artboard_height = Math.floor( (this.artboard_height - (this.print_margins.top + this.print_margins.bottom)) /
        this.img_width);
//~     alert(max_img_widths_on_artboard_height);
    var max_img_heights_on_artboard_width = Math.floor( (this.artboard_width - (this.print_margins.left + this.print_margins.right)) / 
        this.img_height);
//~     alert(max_img_heights_on_artboard_width)
    var max_img_heights_on_artboard_height = Math.floor( (this.artboard_height - (this.print_margins.top + this.print_margins.bottom)) /
        this.img_height);
//~     alert(max_img_heights_on_artboard_height);
    
    // autorotate placeholder to fill well artboard
    var max_placeholders = max_img_widths_on_artboard_width * max_img_heights_on_artboard_height;
    var max_placeholders_rotated = max_img_widths_on_artboard_height * max_img_heights_on_artboard_width;
    max_num_of_placeholders = max_placeholders;
//~     alert(max_placeholders, 'max_placeholders');
//~     alert(max_placeholders_rotated, 'max_placeholders_rotated');
    if (max_placeholders_rotated > max_placeholders) {
        rotate_img_dimensions = true;
        max_num_of_placeholders = max_placeholders_rotated;
        }
    
    if (rotate_img_dimensions) {
//~             alert([this.img_width, this.img_height], 'initial img [w, h]')
            this.img_width = img_placeholder[1];
            this.img_height = img_placeholder[0];
//~             alert([this.img_width, this.img_height], 'final img [w, h]')
        }
    // make document with necessary num of artboards
    
    var num_of_artboards = Math.ceil( num_of_img / max_num_of_placeholders);
//~     alert(num_of_img);
//~     alert(max_num_of_placeholders);
    var pt = 2.83464567 ;
    var doc = makeDoc ('poze', this.artboard_width/pt, this.artboard_height/pt, num_of_artboards, 'mm');

    
    // engine START
    
    var aImg = new Img (this.img_width, this.img_height);
//~     aImg.src = img_paths[0];
//~     
//~             var ao_x = doc.artboards[0].artboardRect[0];
//~             var ao_y = doc.artboards[0].artboardRect[3];
//~             var currentArtboardOrigin = [ao_x, ao_y]; // current Artboard Origin (left bottom)
//~             var matrixPosition = [currentArtboardOrigin[0] + this.print_margins.left, currentArtboardOrigin[1] + this.print_margins.bottom];
//~             var matrixDimensions = [this.artboard_width - (this.print_margins.left + this.print_margins.right), this.artboard_height - (this.print_margins.top + this.print_margins.bottom)];
//~             var x_cells = rotate_img_dimensions ? max_img_heights_on_artboard_width : max_img_widths_on_artboard_width;
//~             var y_cells = rotate_img_dimensions ? max_img_widths_on_artboard_height : max_img_heights_on_artboard_height;
//~             var cells = [x_cells, y_cells];
//~             var cellScaleFactors = [0, 0];
//~             var currentArtboardMatrix = new MatrixJS (matrixPosition, matrixDimensions, cells, cellScaleFactors);
//~             var positions = currentArtboardMatrix.get_mPositions_lrtb();
//~             alert(positions[0]);
//~             aImg.style.left = positions[0][1];
//~             aImg.style.top = postions[0][0];
    
    for (var i = 0; i < num_of_artboards; i ++) {
            var ao_x = doc.artboards[i].artboardRect[0];
            var ao_y = doc.artboards[i].artboardRect[3];
            var currentArtboardOrigin = [ao_x, ao_y]; // current Artboard Origin (left bottom)
            
            var matrixDimensions = [this.artboard_width - (this.print_margins.left + this.print_margins.right), this.artboard_height - (this.print_margins.top + this.print_margins.bottom)];
//~             var matrixPosition = [currentArtboardOrigin[0] + (this.artboard_width - matrixDimensions[0])/2, currentArtboardOrigin[1] + (this.artboard_height - matrixDimensions[1])/2];
            var matrixPosition = [currentArtboardOrigin[0] + this.print_margins.left, currentArtboardOrigin[1] + this.print_margins.bottom];
            
            var x_cells = rotate_img_dimensions ? max_img_heights_on_artboard_width : max_img_widths_on_artboard_width;
            var y_cells = rotate_img_dimensions ? max_img_widths_on_artboard_height : max_img_heights_on_artboard_height;
            var cells = [x_cells, y_cells];
            var cellScaleFactors = [0, 0];
            var currentArtboardMatrix = new MatrixJS (matrixPosition, matrixDimensions, cells, cellScaleFactors);
            var positions = currentArtboardMatrix.get_mPositions_lrtb();
//~             alert (matrixDimensions);
//~             alert([this.artboard_width, this.artboard_height])
            // render images on every artboard
            
            for (var j = 0; j < max_num_of_placeholders; j ++) {
                aImg.src = img_paths[ (i * max_num_of_placeholders) + j ];
                aImg.style.left = positions[ j ][0];
                aImg.style.top = positions[ j ][1] + this.img_height;
                
                aImg.render();
                }
            }

// var positions = myMatrix.get_mPositions_lrtb ();
// // alert (positions[0])

// for (var j = 0; j < paths.length; j++) {
//     aImg.src = paths[j];

//     aImg.style.left = positions[j][1];
//     aImg.style.top = positions[j][0];
//     aImg.render()
            
            
//~         }
    
    
    
       
    };

document = new ImgDocumentCreator(null, null, null, null, null, { left: 7*pt, right: 7*pt, top: 7*pt, bottom:7*pt});
document.set_artboard_dimensions();
document.set_img_dimensions();
document.select_img_folder();
document.render();